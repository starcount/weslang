# Copyright 2014-present Deezer.com
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import fileinput
import shlex


libs = {}


def get_build_rule(rule, objective, out, sources, flags, deps):
    lines = [
        '%s(' % rule,
        "    name = '%s'," % objective,
    ]
    if out:
        lines.append("    out = '%s'," % out)

    if sources:
        lines.append('    srcs = [')
        lines.extend("        '%s'," % s for s in sources)
        lines.append('    ],')

    if deps:
        lines.append('    deps = [')
        lines.extend("        '%s'," % d for d in deps)
        lines.append('    ],')

    if flags:
        lines.append('    flags = [')
        lines.extend("        '%s'," % f for f in flags)
        lines.append('    ],')

    lines.extend([
        '    visibility = [',
        "        'PUBLIC',",
        '    ],'
    ])
    lines.extend([')', ''])

    return '\n'.join(lines)


def get_binary(objective, sources, flags, deps):
    return get_build_rule(
        'cpp_binary', objective, objective, sources, flags, deps)


def get_library(objective, sources, flags, deps):
    return get_build_rule(
        'cpp_library', objective, None, sources, flags, deps)


def get_test(objective, sources, flags, deps):
    return get_build_rule(
        'cpp_test', objective, None, sources, flags, deps)


def clean_flags(flags, exclude):
    return [f for f in flags if f not in exclude]


def convert(command):
    tokens = shlex.split(command)
    sources = []
    objective = None
    flags = []
    deps = []

    assert tokens[0] == 'g++'
    assert tokens[-2] == '-o'
    objective = tokens[-1]

    for token in tokens[1:-2]:
        if token.endswith('.cc') or token.endswith('.h'):
            sources.append('internal/%s' % token)
        else:
            flags.append(token)

    if objective.startswith('lib'):
        libs[objective] = set(sources)
    else:
        for lib, lib_sources in libs.iteritems():
            if lib_sources < set(sources):
                sources = list(set(sources) - lib_sources)
                deps.append(':%s' % lib)

    sources.sort()

    # Remove defaults
    flags = clean_flags(flags, ['-O2', '-m64'])
    if '_unittest' in objective:
        return get_test(objective, sources, flags, deps)
    elif objective.endswith('.so') and objective.startswith('lib'):
        flags = clean_flags(flags, ['-shared', '-fPIC'])
        return get_library(objective, sources, flags, deps)
    else:
        return get_binary(objective, sources, flags, deps)


def parse(filenames):
    in_command = False
    command_lines = []
    print '''# BUCK file autogenerated by the tool compile2buck.py

include_defs('//third_party/cld2/DEFS')

'''
    for line in fileinput.input(filenames):
        line = line.strip()
        continue_line = False
        if line.endswith('\\'):
            line = line[:-1].strip()
            continue_line = True

        if line.startswith('g++'):
            in_command = True

        if in_command and line:
            command_lines.append(line)

        if in_command and not continue_line:
            in_command = False
            command = ' '.join(command_lines)
            print convert(command)
            command_lines = []


if __name__ == '__main__':
    parse([
        'internal/compile_libs.sh',
        'internal/compile_full.sh',
        'internal/compile.sh',
        # 'internal/compile_dynamic.sh',
    ])
    # The last file is commented out because the compilation fails. It is
    # probably due to the fact that the option -D has a space on it.
